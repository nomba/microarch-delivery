# Проблема

Так как мы в Read-cтеке отказываемся от доменного слоя (Domain), что логично (не меняем состояние системы в запросах Query),
то я хочу использовать EntityFramework вместо ADO.net (Dapper). Но `ApplicationDbContext` сконфигурирован в сборке `DeliveryApp.Infrastructure`, и
я не могу его просто заиспользовать, так как сослаться из "кора" на "инфраструктуру" нельзя по "Clean Architecture".

# Варианты решения

### Дублирование

Дублирование `ApplicationDbContext` с его конфигурацией в "коре" кажется сомнительной идеей, в чем тогда смысл выделения "инфраструктуры".

### Реорганизация

Как вариант, это дробить приложение по другому, НЕ на: 
 - `DeliveryApp.Api`, 
 - `DeliveryApp.Core`, 
 - `DeliveryApp.Infrastructure`.

А, например, так, по аналогии с [Ordering-сервис eShop](https://github.com/dotnet/eShop/tree/main/src):
- `DeliveryApp.Api`,
- `DeliveryApp.Domain`,
- `DeliveryApp.Infrastructure`

т.е. оставить в "коре" только домен, так как изоляция для него крайне важна,
запросы и команды перенести все в "апи". **Тогда при реализации запросов можно ссылаться на "инфраструктуру"**.

Основной минус, состоит в том, что если добавить новый интерфейс (UI/API) с требованием, что он должен быть оформлен отдельной сборкой, то придется выделять/копировать команды и запросы.
Но мне кажется такой кэйс маловероятен, так как сама сборка `DeliveryApp.Api` является "хорошей" точкой интеграции, поверх неё всегда можно произвести взаимодействие с другим участником (приложением) системы.
Например, в консольном приложении можно вызывать методы HTTP, а не использовать напрямую команды/запросы, более того, в самой сборке можно поддержать консольный интерфейс,
и положить его в `DeliveryApp.Api\Adapters`.

### Объединение

Еще вариант, на мой взгляд, самый оптимальный – **это одна сборка**. Все слои будут помещены в отдельные папки, например:

- `DeliveryApp\Application`
- `DeliveryApp\Domain`
- `DeliveryApp\Ports`
- `DeliveryApp\Adapters`

Для поддержания порядка можно использовать юнит-тесты для проверки архитектуры (NetArchTest, ArchUnitNET). 
При это остается возможность декомпозиции на отдельные сборки при необходимости.  

# Причина проблемы

Декомпозиция на сборки выбрана с учетом "Clean Architecture", но при этом, в реализации запросов (Query) мы, напрямую, обращаемся в "инфраструктуру" (Dapper, EF и т.д.), не через порты,
т.е. нарушаем изоляцию "кора", соответственно не следуем каноническому подходу.
